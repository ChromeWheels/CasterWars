using UnityEngine;
using System.Collections;
using System.Collections.Generic;

/**
 * The controller for the maps
 */
public class MapsController : MonoBehaviour {

	public static MapsController S;
	
	public GameObject highlightAttackPrefab = null; //!< The GameObject that is used for highlighting the available tiles that can be attacked
	public GameObject highlightCapturePrefab = null; //!< The GameObject that is used for highlighting the available tiles that can be captured
	public GameObject highlightMovePrefab = null; //!< The GameObject that is used for highlighting the available tiles that can be moved to

	[HideInInspector]
	public List<Vector2> Neighbors {
		get { return neighbors; }
		private set { neighbors = value; }
	} //!< Property method of Vector2[] neighbors

	private Dimensions dimensions = null; //!< Local copy of the map's dimensions
	private List<GameObject> highlightedTiles = null; //!< Temporary list of highlighted tiles
	private List<int> locationIndexes = null; //!< Temporary list of unique neighbor locations. Used to prevent duplicate locations in List<Vector2> locations
	private Map mapScript = null; //!< Local reference to the Map's script
	private List<Vector2> neighbors = null; //!< Temporary list of neighbors
	private Tiles tilesScript = null; //!< Local reference to the Tiles script instance
	private int startingIndex = 0; //!< Variable used when getting neighbors to prevent adding the starting tile to poosible neighbors

	/**
	 * Called when the script is loaded, before the game starts
	 */
	void Awake () {
		S = this;
	}

	/**
	 * Constructs and loads the map from index
	 * @param index The index of the map from the list of maps
	 */
	public void construct (int index) {
		// Initialize the variables
		highlightedTiles = new List<GameObject> ();
		tilesScript = Tiles.S;

		// Get the map from the collections
		Maps mapsCollection = Maps.S;
		GameObject mapPrefab = mapsCollection.maps [index];

		// Instantiate the new map
		GameObject map = Instantiate (mapPrefab, new Vector3 (0, -0.1f, 0), Quaternion.identity) as GameObject;

		// For some reason, the map is instatiated upside-down
		map.transform.Rotate (0, 180, 0);

		// Name the map a cool name
		map.name = "Map";

		// Set the parent
		map.transform.SetParent (transform);

		// Get the variables from the map
		mapScript = map.GetComponent<Map> ();

		// Move the map into place
		map.transform.position = new Vector3 ((mapScript.dimensions.width / 2) - 0.5f, map.transform.position.y, (mapScript.dimensions.height / 2) - 0.5f);

		// Move the camera to be zoomed out at the start
		RemoteCamera rcScript = RemoteCamera.S;
		Vector3 cameraPosition = new Vector3 ((mapScript.dimensions.height / 2), (Mathf.Min (mapScript.dimensions.width, mapScript.dimensions.height) / 2), (mapScript.dimensions.height / 2));
		if (rcScript.doScrollMove) {
			rcScript.doScrollMove = false;
			rcScript.moveTo (cameraPosition);
			rcScript.doScrollMove = true;
		} else {
			rcScript.moveTo (cameraPosition);
		}
	}

	/** 
	 * Gets all of the neighboring tiles within a movement range
	 * @param location Location of unit's current position
	 * @param range Amount that player can move current unit
	 * @return List of available neighbors
	 */
	public void setNeighbors (Vector2 location, float range) {
		locationIndexes = new List<int> ();
		neighbors = new List<Vector2> ();
		startingIndex = convertToIndex (location);

		traverseNeighbors (location, range);
	}

	/**
	 * Loops through the Vector2 array of locations that is generated by getNeightbors and creates highlighted tiles
	 * @see HighlightActions
	 * @param action The action that will take place. Used to show different tiles per what the player is about to do 
	 */
	public void highlightNeighbors (HighlightActions action) {
		GameObject newHighlight = null;

		foreach (Vector2 location in neighbors) {
			Vector3 pos = new Vector3 (location.x, -0.59f, (dimensions.height - location.y));

			switch (action) {
			case HighlightActions.Attack:
				newHighlight = Instantiate (highlightAttackPrefab, pos, Quaternion.identity) as GameObject;
				break;
			case HighlightActions.Capture:
				newHighlight = Instantiate (highlightCapturePrefab, pos, Quaternion.identity) as GameObject;
				break;
			case HighlightActions.Move:
				newHighlight = Instantiate (highlightMovePrefab, pos, Quaternion.identity) as GameObject;
				break;
			}

			newHighlight.transform.parent = transform;
			highlightedTiles.Add (newHighlight);
		}
	}

	/**
	 * Removes all currently highlighted tiles
	 */
	public void removeHighlights () {
		foreach (GameObject tile in highlightedTiles) {
			Destroy (tile);
		}

		highlightedTiles.Clear ();
	}

	/**
	 * A recursive function that moves over the neighboring tiles
	 * Runs a breadth first search of the neighboring tiles for all available movement possibilities.
	 * @param location Location of the starting point tile
	 * @param range Remaining movement left
	 */
	private void traverseNeighbors (Vector2 location, float range) {
		int index = convertToIndex (location);
		float movementCost = tilesScript.getMovementCost (getTileType (location));

		if (canMoveFrom (location, range, movementCost)) {
			range -= movementCost;

			// Go left
			if (canMoveTo (new Vector2 (location.x - 1, location.y))) {
				traverseNeighbors (new Vector2 (location.x - 1, location.y), range);
			}

			// Go down
			if (canMoveTo (new Vector2 (location.x, location.y + 1))) {
				traverseNeighbors (new Vector2 (location.x, location.y + 1), range);
			}

			// Go right
			if (canMoveTo (new Vector2 (location.x + 1, location.y))) {
				traverseNeighbors (new Vector2 (location.x + 1, location.y), range);
			}

			// Go up
			if (canMoveTo (new Vector2 (location.x, location.y - 1))) {
				traverseNeighbors (new Vector2 (location.x, location.y - 1), range);
			}
		}

		if (!locationIndexes.Contains (index) && index != startingIndex) {
			locationIndexes.Add (index);
			neighbors.Add (location);
		}
	}

	/**
	 * Generated a unique index to prevent duplicate array entries by traverseNeighbors
	 * @see traverseNeighbors
	 * @param location Location of the tile
	 * @return A unique index integer
	 */
	private int convertToIndex (Vector2 location) {
		return (int) (location.x + (dimensions.width * location.y));
	}

	/**
	 * Check to see if the current unit can be moved. Along with canMovedTo
	 * @see canMoveTo
	 * @param location Location of current tile
	 * @param range Available movement left
	 * @param movementCost Cost of moving from current tile
	 * @return Boolean value of availability to move from current tile
	 */
	private bool canMoveFrom (Vector2 location, float range, float movementCost) {
		bool unitOnTile = false;

		return (!unitOnTile && (range - movementCost) >= 0);
	}

	/**
	 * Check to see if the current unit can be moved. Along with canMovedFrom
	 * @see canMoveFrom
	 * @param location Location of future tile
	 * @return Boolean value of availability to move to provided tile
	 */
	private bool canMoveTo (Vector2 location) {
		bool canMove = tilesScript.getCanMove (getTileType (location));
		bool unitOnTile = false;

		return (!unitOnTile && canMove);
	}

	/**
	 * Get the tile type if the provided tile location
	 * @param location Location of the tile to get the type
	 * @return The type of the provided tile
	 */
	private int getTileType (Vector2 location) {
		return mapScript.tiles [(int)location.y, (int)location.x] - 1;
	}
}
